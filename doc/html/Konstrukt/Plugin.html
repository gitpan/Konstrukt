<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>Konstrukt::Plugin</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="cpan" type="text/css" href="../cpan.css" media="all" >

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::CustomHTML v,
  using Pod::Simple::PullParser v2.02,
  under Perl v5.008008 at Tue Sep 26 20:07:26 2006 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::CustomHTML, and/or subclassing Pod::Simple::CustomHTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::CustomHTML for advice.
   See 'perldoc Pod::Simple::CustomHTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Writing_own_plugins'>Writing own plugins</a>
    <li class='indexItem indexItem2'><a href='#Using_existing_plugins'>Using existing plugins</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#EXPORTS'>EXPORTS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#use_plugin'>use_plugin</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#new'>new</a>
    <li class='indexItem indexItem2'><a href='#init'>init</a>
    <li class='indexItem indexItem2'><a href='#install'>install</a>
    <li class='indexItem indexItem2'><a href='#prepare_again'>prepare_again</a>
    <li class='indexItem indexItem2'><a href='#execute_again'>execute_again</a>
    <li class='indexItem indexItem2'><a href='#execution_stage'>execution_stage</a>
    <li class='indexItem indexItem2'><a href='#prepare'>prepare</a>
    <li class='indexItem indexItem2'><a href='#execute'>execute</a>
    <li class='indexItem indexItem2'><a href='#reset_nodes'>reset_nodes</a>
    <li class='indexItem indexItem2'><a href='#add_node'>add_node</a>
    <li class='indexItem indexItem2'><a href='#get_nodes'>get_nodes</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Konstrukt::Plugin - Base class for the Konstrukt plugins.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Writing_own_plugins"
>Writing own plugins</a></h2>

<pre>        package Konstrukt::Plugin::my_plugin;
        
        use base &#39;Konstrukt::Plugin&#39;;
        
        #overwrite (some of) the methods:
        sub execute {
                my ($self, $tag) = @_;
                #...
                $self-&#62;reset_nodes();
                #...
                $self-&#62;add_node(&#39;foo&#39;);
                #...
                return $self-&#62;get_nodes();
        }
        
        #...</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Using_existing_plugins"
>Using existing plugins</a></h2>

<pre>        use Konstrukt::Plugin; #import use_plugin
        
        #...
        
        sub init {
                #...
                #if you use a plugin in several places you may load it once at initialization
                $self-&#62;{some_plugin} = use_plugin &#39;some_plugin&#39; or return undef;
                #...
        }
        
        #...
        
        sub my_method {
                #if you saved the plugin object at init, you may use it like this
                $self-&#62;{some_plugin}-&#62;some_method();
                
                #alternatively. but more unsafe (use_plugin may return undef on error)
                my $plugin = use_plugin &#39;some_plugin&#39;;
                $plugin-&#62;some_method();
                
                #or even
                use_plugin(&#39;some_plugin&#39;)-&#62;some_method();
        }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Base class for Konstrukt plugins. To write your own plugins you have to overload some of the methods of this class.</p>

<p>Take a look at the documentation of the methods and at the <a href="#SYNOPSIS" class="podlinkpod"
>&#34;SYNOPSIS&#34;</a> to get an overview of what has to be done to create an own plugin.</p>

<p>You might also want to take a look at <a href="../Konstrukt/Doc/PluginDevelopment.html" class="podlinkpod"
>Konstrukt::Doc::PluginDevelopment</a>, at <a href="../Konstrukt/SimplePlugin.html" class="podlinkpod"
>Konstrukt::SimplePlugin</a> and at the plugins that already exist.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="EXPORTS"
>EXPORTS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="use_plugin"
>use_plugin</a></h2>

<p>Exported by default. Allows you to load a plugin easily and get its object:</p>

<pre>        use Konstrukt::Plugin; #import use_plugin
        my $plugin = use_plugin &#39;someplugin&#39;;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="new"
>new</a></h2>

<p>Constructor of this class</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="init"
>init</a></h2>

<p>Method that will be called right before the first usage within a request. Here you should do per request initialization work like definition of <a href="../Konstrukt/Settings.html#default" class="podlinkpod"
>default settings</a>.</p>

<p>Should be overridden by the inheriting class.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="install"
>install</a></h2>

<p>Should be overloaded by your plugin and its backends, if they need installation before the first run.</p>

<p>The installation should be performed according to the current settings like the selected backend and database settings as well as the template path.</p>

<p>Usually in the backend module this method will create database tables for your plugin. The &#34;main&#34; plugin should load the backend plugin on init, that is defined in the settings, and then the install method will be called automatically on the backend module when it gets loaded.</p>

<p>The &#34;main&#34; plugin may create templates that are needed for the output.</p>

<p>Will be called automatically after the plugin has been loaded and <code>init()</code>ialized, if the setting <code>autoinstall</code> is true.</p>

<p>You may want to use <a href="../Konstrukt/Lib.html#plugin_dbi_install_helper" class="podlinkpod"
>&#34;plugin_dbi_install_helper&#34; in Konstrukt::Lib</a> for the installation of your DBI backend plugins and <a href="../Konstrukt/Lib.html#plugin_file_install_helper" class="podlinkpod"
>&#34;plugin_file_install_helper&#34; in Konstrukt::Lib</a> for the installation of default templates for your plugin, which can be embedded at the end of your plugin module.</p>

<p>Don&#39;t confuse this method with <a href="#init" class="podlinkpod"
>&#34;init&#34;</a>, which will be called once on <b>every</b> request.</p>

<p><b>Parameters:</b></p>

<p>none</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="prepare_again"
>prepare_again</a></h2>

<p>If this method returns a true value the result generated by this plugin will be piped through the prepare run before it will be inserted into the result tree.</p>

<p>Should return true, when this plugin may generate plaintext, that will parse to dynamic content (e.g. return plaintext nodes that contain Konstrukt tags (&#60;&#38; .. &#38;&#62;)), or tag nodes that should be prepare()&#39;d.</p>

<p>In detail all returned plaintext nodes will be parsed for special tags and existing tag nodes will be prepare()&#39;d recursively.</p>

<p>As this is a time consuming job (especially when your tag has many/deeply nested children), you should only return true, if your plugin really generates new tags (as plaintext or as tag nodes).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="execute_again"
>execute_again</a></h2>

<p>If this method returns a true value the result generated by this plugin will be piped through the execute run before it will be inserted into the result tree.</p>

<p>Should return true, when this plugin may generate (dynamic) tag nodes that shall be executed (e.g. return a template or perl node).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="execution_stage"
>execution_stage</a></h2>

<p>Returns the execution stage of the tag. Defaults to 1.</p>

<p>Usually all tags are <a href="#execute" class="podlinkpod"
>&#34;execute&#34;</a>d in the order of appearence in the processed document.</p>

<p>But sometimes you might want a tag to be executed last/later, although it&#39;s located at the top of the document. The <code>execution_stage</code>s allow you to specifiy an execution order that&#39;s different from the appearance order.</p>

<pre>        &#60;&#38; perl execution_stage=&#34;2&#34; &#38;&#62;print `date +%H:%M:%S`&#60;&#38; / &#38;&#62;
        &#60;&#38; perl &#38;&#62;print `date +%H:%M:%S`; sleep 2&#60;&#38; / &#38;&#62;</pre>

<p>Will actually be rendered to something like:</p>

<pre>        10:50:54
        10:50:52</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="prepare"
>prepare</a></h2>

<p>The prepare method of this plugin.</p>

<p>This sub should be overridden by the inheriting class.</p>

<p>Every content that will be the same with each page request (&#34;static&#34; content) should be processed by the plugin in this stage.</p>

<p>If you want to replace the tag with other nodes, you must return a (dummy) tag <a href="../Konstrukt/Parser/Node.html" class="podlinkpod"
>node</a> whose children will replace the original tag. You may also just return a scalar(ref). You may want to use <a href="#reset_nodes" class="podlinkpod"
>&#34;reset_nodes&#34;</a>, <a href="#add_node" class="podlinkpod"
>&#34;add_node&#34;</a> and <a href="#get_nodes" class="podlinkpod"
>&#34;get_nodes&#34;</a> for an easier node handling.</p>

<p>Note that you should return <code>undef</code> if you modify the tree yourself instead of returning replacement nodes.</p>

<p>(Some of) the nodes passed to your plugin may be dynamic content (i.e. tags that have to be executed on every request as they may produce different output on every request). You can check it like this:</p>

<pre>        if ($tag-&#62;{dynamic}) { ... }</pre>

<p>If <b>your</b> plugin has to do some work in the execute run, you should set the dynamic flag of your tag to a true value to let the parser know, that this tag cannot be finally processed in the prepare run:</p>

<pre>        $tag-&#62;{dynamic} = 1;</pre>

<p>If your plugin returns plaintext that will parse into new tag nodes or if it returns new tag nodes that should be prepare()&#39;d your <a href="#prepare_again" class="podlinkpod"
>&#34;prepare_again&#34;</a> method should return a true value.</p>

<p><b>Parameters</b>:</p>

<ul>
<li>$tag - Reference to the tag node (and its children) that shall be handled. Contains the plugin tag in the parse tree and all related information - espeacially the tag attributes (<code>$tag-</code>{tag}-&#62;{attributes}&#62;) and the content inside the tag:
<pre>        my $node = $tag-&#62;{first_child};
        while (defined $node) {
                #do stuff on $node-&#62;{content}...
                $node = $node-&#62;{next};
        }</pre>
</li>
</ul>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="execute"
>execute</a></h2>

<p>The execute method of this plugin.</p>

<p>This sub should be overridden by the inheriting class.</p>

<p>Every content that may be different on each page request (&#34;dynamic&#34; content) should be processed by the plugin in this stage.</p>

<p>If you want to replace the tag with other nodes, you must return a (dummy) tag <a href="../Konstrukt/Parser/Node.html" class="podlinkpod"
>node</a> whose children will replace the original tag. You may also just return a scalar(ref). You may want to use <a href="#reset_nodes" class="podlinkpod"
>&#34;reset_nodes&#34;</a>, <a href="#add_node" class="podlinkpod"
>&#34;add_node&#34;</a> and <a href="#get_nodes" class="podlinkpod"
>&#34;get_nodes&#34;</a> for an easier node handling.</p>

<p>Note that you should return <code>undef</code> if you modify the tree yourself instead of returning replacement nodes.</p>

<p><b>Parameters</b>:</p>

<ul>
<li>$tag - Reference to the tag node (and its children) that shall be handled. Contains the plugin tag in the parse tree and all related information - espeacially the tag attributes (<code>$tag-</code>{tag}-&#62;{attributes}&#62;) and the content inside the tag:
<pre>        my $node = $tag-&#62;{first_child};
        while (defined $node) {
                #do stuff on $node-&#62;{content}...
                $node = $node-&#62;{next};
        }</pre>
</li>
</ul>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="reset_nodes"
>reset_nodes</a></h2>

<p>Creates a new node collection. See <a href="#push_node" class="podlinkpod"
>&#34;push_node&#34;</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="add_node"
>add_node</a></h2>

<p>This method allows you to add a node to the list of temporary nodes. Usually you would use it like this, if your plugin will return some nodes:</p>

<pre>        $self-&#62;reset_nodes();
        $self-&#62;add_node(&#39;some plaintext node&#39;);
        $self-&#62;add_node(Konstrukt::Parser::Node-&#62;new({ type =&#62; &#39;comment&#39;, content =&#62; &#39;&#60;!-- comment node --&#62;&#39;}));
        #you may also add any other tag
        return $self-&#62;get_nodes();</pre>

<p>If the argument is no <code>Konstrukt::Parser::Node</code> object, a plaintext node with the argument as content will be created.</p>

<p><b>Parameters</b>:</p>

<ul>
<li>$node - <code>Konstrukt::Parser::Node</code> object.</li>
</ul>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_nodes"
>get_nodes</a></h2>

<p>Retruns the node, whose children are the collected nodes.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Copyright 2006 Thomas Wittek (mail at gedankenkonstrukt dot de). All rights reserved.</p>

<p>This document is free software. It is distributed under the same terms as Perl itself.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../Konstrukt/Plugin/date.html" class="podlinkpod"
>Konstrukt::Plugin::date</a>, <a href="../Konstrukt/Plugin/upcase.html" class="podlinkpod"
>Konstrukt::Plugin::upcase</a>, <a href="../Konstrukt/Parser/Node.html" class="podlinkpod"
>Konstrukt::Parser::Node</a>, <a href="../Konstrukt.html" class="podlinkpod"
>Konstrukt</a></p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
